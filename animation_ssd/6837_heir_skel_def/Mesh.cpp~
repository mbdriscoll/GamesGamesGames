/*#include "Mesh.h"

using namespace std;

void Mesh::load( const char* filename )
{
	// 2.1.1. load() should populate bindVertices, currentVertices, and faces

	// Add your code here.
  /*
  string ss;
  ifstream myfile(filename);

  while (myfile >> ss) {

    Vector3f v;

    if (ss == "v") {
      myfile >> v[0] >> v[1] >> v[2];
      bindVertices.push_back(v);
    }
    else if (ss == "f") {
      string chnk1;
      string chnk2;
      string chnk3;
      myfile >> chnk1 >> chnk2 >> chnk3;
      int firstSlash = chnk1.find_first_of("/");
      string a = chnk1.substr(0, firstSlash);
      
      int secondSlash = chnk2.find_first_of("/");
      string d = chnk2.substr(0, secondSlash);
      
      int thirdSlash = chnk3.find_first_of("/");
      string g = chnk3.substr(0, thirdSlash);

      Tuple3u facesTup;
      facesTup[0] = atoi(a.c_str());
      facesTup[1] = atoi(d.c_str());
      facesTup[2] = atoi(g.c_str());
      
      faces.push_back(facesTup);
      
    }
    else {} // do nothing
  }
	// make a copy of the bind vertices as the current vertices
	currentVertices = bindVertices;
  
}

void Mesh::draw()
{
	// Since these meshes don't have normals
	// be sure to generate a normal per triangle.
	// Notice that since we have per-triangle normals
	// rather than the analytical normals from
	// assignment 1, the appearance is "faceted".
  /*
  // Clear the rendering window
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  // Position camera at [0,0,5], looking at [0,0,0]
  gluLookAt(0.0, 0.0, 5.0,
	    0.0, 0.0, 0.0, 
	    0.0, 1.0, 0.0);

  	// Here are some colors you might use - feel free to add more
    GLfloat diffColors[4][4] = { {0.5, 0.5, 0.9, 1.0},
                                 {0.9, 0.5, 0.5, 1.0},
                                 {0.5, 0.9, 0.3, 1.0},
                                 {0.3, 0.8, 0.9, 1.0} };

  // use the first color entry as the diffuse color - not anymore
  glMatieralfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, diffColors[0]);

  	// Define specular color and shininess
    GLfloat specColor[] = {1.0, 1.0, 1.0, 1.0};
    GLfloat shininess[] = {100.0};

	// Note that the specular color and shininess can stay constant
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, specColor);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, shininess);
  
    // Set light properties

    // Light color (RGBA)
    GLfloat Lt0diff[] = {1.0,1.0,1.0,1.0};
    // Light position
	GLfloat Lt0pos[] = {lightPosHoriz, lightPosVert, 5.0f, 1.0f};

    glLightfv(GL_LIGHT0, GL_DIFFUSE, Lt0diff);
    glLightfv(GL_LIGHT0, GL_POSITION, Lt0pos);

   for (unsigned int k=0; k < faces.size(); k++) {

    vector<unsigned> faceTup = faces[k];
    int a_ = faceTup[0];
    int d_ = faceTup[1];
    int g_ = faceTup[2];


    vector<Vector3f> vecv = m_mesh.currentVertices;

    glBegin(GL_TRIANGLES);
    glNormal3d(vecn[c_-1][0], vecn[c_-1][1], vecn[c_-1][2]);
    glVertex3d(vecv[a_-1][0], vecv[a_-1][1], vecv[a_-1][2]);
    glNormal3d(vecn[f_-1][0], vecn[f_-1][1], vecn[f_-1][2]);
    glVertex3d(vecv[d_-1][0], vecv[d_-1][1], vecv[d_-1][2]);
    glNormal3d(vecn[i_-1][0], vecn[i_-1][1], vecn[i_-1][2]);
    glVertex3d(vecv[g_-1][0], vecv[g_-1][1], vecv[g_-1][2]);
    glEnd();


  }
    
    // Dump the image to the screen.
    glutSwapBuffers();

  

}

void Mesh::loadAttachments( const char* filename, int numJoints )
{
	// 2.2. Implement this method to load the per-vertex attachment weights
	// this method should update m_mesh.attachments
}
*/



  // SECOND ATTEMPT *********************************************************
  /*
#include "Mesh.h"

using namespace std;

void Mesh::load( const char* filename )
{
	// 2.1.1. load() should populate bindVertices, currentVertices, and faces

  string str;
  ifstream myfile(filename);

  while(myfile >> str) {
    Vector3f vec;

    if (str == "v") {
      myfile >> vec[0] >> vec[1] >> vec[2];
      bindVertices.push_back(vec);
    }
    else if (str == "f") {
      string first, second, third;

      myfile >> first >> second >> third;

      int split_one = first.find_first_of("/");
      int split_two = second.find_first_of("/");
      int split_three = third.find_first_of("/");

      string one = first.substr(0, split_one);
      string two = second.substr(0, split_two);
      string three = third.substr(0, split_three);
      
      Tuple3u face = (atoi(one.c_str()), atoi(two.c_str()), atoi(three.c_str()));

      faces.push_back(face);

    }
    else {
      cout << "Invalid file." << endl;
    }

  }
	// make a copy of the bind vertices as the current vertices
	currentVertices = bindVertices;
}

void Mesh::draw()
{
	// Since these meshes don't have normals
	// be sure to generate a normal per triangle.
	// Notice that since we have per-triangle normals
	// rather than the analytical normals from
	// assignment 1, the appearance is "faceted".


    // Clear the rendering window
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // // Rotate the image
     glMatrixMode( GL_MODELVIEW );  // Current matrix affects objects positions
     glLoadIdentity();              // Initialize to the identity

    // Position the camera at [0,0,5], looking at [0,0,0],
    // with [0,1,0] as the up direction.
    gluLookAt(0.0, 0.0, 5.0,
              0.0, 0.0, 0.0,
              0.0, 1.0, 0.0);

    // Set material properties of object

	// Here are some colors you might use - feel free to add more
    GLfloat diffColors[4][4] = { {0.5, 0.5, 0.9, 1.0},
                                 {0.9, 0.5, 0.5, 1.0},
                                 {0.5, 0.9, 0.3, 1.0},
                                 {0.3, 0.8, 0.9, 1.0} };
    
	// Here we use the first color entry as the diffuse color
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, diffColors[0]);

	// Define specular color and shininess
    GLfloat specColor[] = {1.0, 1.0, 1.0, 1.0};
    GLfloat shininess[] = {100.0};

	// Note that the specular color and shininess can stay constant
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, specColor);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, shininess);
  
    // Set light properties

    // Light color (RGBA)
    GLfloat Lt0diff[] = {1.0,1.0,1.0,1.0};
    // Light position
	GLfloat Lt0pos[] = {1, 1, 5.0f, 1.0f}; // first and second = 1.0, 1.0

    glLightfv(GL_LIGHT0, GL_DIFFUSE, Lt0diff);
    glLightfv(GL_LIGHT0, GL_POSITION, Lt0pos);
    
    for (unsigned ii = 0; ii < faces.size(); ii++) {
    	
    	Tuple3u tup = faces[ii];
    	
    	int a = tup[0];
    	int d = tup[1];
    	int g = tup[2];
    	
    	vector<Vector3f> vecv = currentVertices;
    	
    	Vector3f v1 = Vector3f(vecv[a-1][0], vecv[a-1][1], vecv[a-1][2]);
    	Vector3f v2 = Vector3f(vecv[d-1][0], vecv[d-1][1], vecv[d-1][2]);
    	Vector3f v3 = Vector3f(vecv[g-1][0], vecv[g-1][1], vecv[d-1][2]);
    	
    	Vector3f e1 = Vector3f(v2[0]-v1[0], v2[1]-v1[1], v2[2]-v1[2]);
    	Vector3f e2 = Vector3f(v3[0]-v2[0], v3[1]-v2[1], v3[2]-v2[2]);
    	
    	Vector3f normal = Vector3f().cross(e1, e2);
    	Vector3f norm = normal.normalized();
    	
      
    	glBegin(GL_TRIANGLES);
    	glVertex3d(vecv[a-1][0], vecv[a-1][1], vecv[a-1][2]);
    	glVertex3d(vecv[d-1][0], vecv[d-1][1], vecv[d-1][2]);
    	glVertex3d(vecv[g-1][0], vecv[g-1][1], vecv[g-1][2]);
    	glNormal3d(norm[0], norm[1], norm[2]);
    	glEnd();

    }


    // Dump the image to the screen.
    glutSwapBuffers();


  

}

void Mesh::loadAttachments( const char* filename, int numJoints )
{
	// 2.2. Implement this method to load the per-vertex attachment weights
	// this method should update m_mesh.attachments
	
	  string str;
	  ifstream myfile(filename);
	  vector<float> weights;
	  weights.push_back(0);
	  while(myfile >> str) {
		  
		  weights.push_back(atof(str.c_str()));
		  for (int ii = 1; ii < numJoints; ii++) { // start at 1 since str is the first
			  string next;
			  myfile >> next;
			  weights.push_back(atof(next.c_str()));
		  }
		  attachments.push_back(weights);
	  }
}
*/


#include "Mesh.h"

using namespace std;

void Mesh::load( const char* filename )
{
	// 2.1.1. load() should populate bindVertices, currentVertices, and faces

  string str;
  ifstream myfile(filename);

  while(myfile >> str) {
    Vector3f vec;

    if (str == "v") {
      myfile >> vec[0] >> vec[1] >> vec[2];
      bindVertices.push_back(vec);
    }
    else if (str == "f") {
      string first, second, third;

      myfile >> first >> second >> third;

      //printf("Read: %s - %s - %s\n", first.c_str(), second.c_str(), third.c_str());
      Tuple3u face(atoi(first.c_str()), atoi(second.c_str()), atoi(third.c_str()));

      //printf("Got face: %i-%i-%i\n", face[0], face[1], face[2]);

      faces.push_back(face);

    }
    else {
      cout << "Invalid file." << endl;
    }

  }
	// make a copy of the bind vertices as the current vertices
	currentVertices = bindVertices;
}

void Mesh::draw()
{
	// Since these meshes don't have normals
	// be sure to generate a normal per triangle.
	// Notice that since we have per-triangle normals
	// rather than the analytical normals from
	// assignment 1, the appearance is "faceted".


	
    
	cout << "faces.size = " << faces.size() << endl;

    	glBegin(GL_TRIANGLES);

    for (unsigned ii = 0; ii < faces.size(); ii++) {
      //cout << "faces.size (in loop) = " << faces.size() << endl;
    	Tuple3u tup = faces[ii];
    	
    	int a = tup[0];
    	int d = tup[1];
    	int g = tup[2];
    	
    	Vector3f v1 = Vector3f(currentVertices[a-1][0], currentVertices[a-1][1], currentVertices[a-1][2]);
    	Vector3f v2 = Vector3f(currentVertices[d-1][0], currentVertices[d-1][1], currentVertices[d-1][2]);
    	Vector3f v3 = Vector3f(currentVertices[g-1][0], currentVertices[g-1][1], currentVertices[g-1][2]);
    	
    	Vector3f e1 = Vector3f(v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]);
    	Vector3f e2 = Vector3f(v3[0]-v2[0], v3[1]-v2[1], v3[2]-v2[2]);
    	
    	Vector3f normal = Vector3f::cross(e1, e2);
    	Vector3f norm = -normal.normalized();
    	

    	glNormal3f(norm[0], norm[1], norm[2]);
    	glVertex3f(v1[0], v1[1], v1[2]);
    	glVertex3f(v2[0], v2[1], v2[2]);
    	glVertex3f(v3[0], v3[1], v3[2]);
    
    	//printf("%f,%f,%f - %f,%f,%f - %f,%f,%f\n", v1[0], v1[1], v1[2], v2[0], v2[1], v2[2], v3[0], v3[1], v3[2]);

    }
    
    glEnd();	

}

void Mesh::loadAttachments( const char* filename, int numJoints )
{
	// 2.2. Implement this method to load the per-vertex attachment weights
	// this method should update m_mesh.attachments
	
	  string str;
	  ifstream myfile(filename);

	  while(myfile >> str) {
		  vector<float> weights;
		  weights.push_back(0);
		  weights.push_back(atof(str.c_str()));
		  for (int ii = 1; ii < numJoints; ii++) { // start at 1 since str is the first
			  string next;
			  myfile >> next;
			  weights.push_back(atof(next.c_str()));
		  }
		  attachments.push_back(weights);
	  }
}
